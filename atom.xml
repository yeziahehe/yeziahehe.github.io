<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ivan&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yeziahehe.com/"/>
  <updated>2019-05-30T08:32:07.491Z</updated>
  <id>http://yeziahehe.com/</id>
  
  <author>
    <name>叶帆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 xx_ 前缀向 xx. 命名空间协议转变</title>
    <link href="http://yeziahehe.com/2019/05/30/LazySequence/"/>
    <id>http://yeziahehe.com/2019/05/30/LazySequence/</id>
    <published>2019-05-30T03:09:30.000Z</published>
    <updated>2019-05-30T08:32:07.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在写新项目的时候，在一个下拉组件中看到了 .es 的语法，于是想到了很多的第三库如 Kingfisher, RxSwift 都使用了类似的 .kf, .rx 语法，从而引发了一段思考。</p><p>首先说说这个语法出现的场景，通常自己写的类或者封装的组件都会自己加前缀，但是在系统方法扩展的时候官方在 OC 时代给到的推荐是 <strong>前缀_</strong> 的方式，在 Swift 语言出现后一段时间，开发者保留了这样的写法，但是因为 Swift 语言的发展，以及语言的特性，面向协议编程 (Protocol Oriented Programming，以下简称 POP)，从而引出下面的写法。</p><h1 id="rx"><a href="#rx" class="headerlink" title=".rx"></a>.rx</h1><p>因为是 RxSwift 的使用者，很早的时候记得当时的语法糖是 <strong>rx_</strong>, 这个是非常重度的 OC 语法推荐写法，在自己对系统方法进行扩展的时候需要加上前缀，方式方法名称重复。但是我们发现后续版本中这个语法糖做出了改变，大家可以参考 RxSwift 的这个帖子 <a href="https://github.com/ReactiveX/RxSwift/issues/826" target="_blank" rel="noopener">[RxCocoa] Move from <code>rx_</code> prefix to a <code>rx.</code> proxy (for Swift 3 update ?)</a>，这篇帖子的标题解释了一个很重要的概念，就是 rx_ 向 rx. 转变的时候是由带前缀的方法名称向协议去转变，通过拥有对象的协议去实现扩展方法。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>鉴于上面 RxSwift Issue 时间比较久远，这边提供几个近期的完整实现：</p><ul><li><a href="https://github.com/onevcat/Kingfisher/blob/master/Sources/General/Kingfisher.swift" target="_blank" rel="noopener">喵神的 Kingfisher</a></li><li><a href="https://github.com/apple/swift/blob/master/stdlib/public/core/LazySequence.swift" target="_blank" rel="noopener">Swift 中的 LazySequence</a></li></ul><h2 id="实现-Base"><a href="#实现-Base" class="headerlink" title="实现 Base"></a>实现 Base</h2><p>实现一个 Base 的 Struct/ Class，推荐 Struct。</p><p>这个 Struct 将真实的对象包裹起来，作为一个泛型结构体，不做任何实际操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">KingfisherWrapper</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Protocol-和-kf-方法"><a href="#实现-Protocol-和-kf-方法" class="headerlink" title="实现 Protocol 和 .kf 方法"></a>实现 Protocol 和 .kf 方法</h2><p>定一个 protocol，不实现任何变量方法声明，防止其他的 protocol 继承会修改到变量方法的实现。</p><p>然后实现 protocol 的 extension，提供一个 default implementation，这边其实就是实现了一个 kf 的属性，这个属性是 KingfisherWrapper 的实例，<code>public var kf: KingfisherWrapper&lt;Self&gt;</code> Self 用在协议里面，代表的是遵守协议的对象（类／结构体／枚举）类型，即 Base 类型，根据 Base 类的不同，实现对应类里面的方法。</p><p>这样，就相当于实现了 <code>kf</code> 的命名空间。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">KingfisherCompatible</span>: <span class="title">AnyObject</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">KingfisherCompatible</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Gets a namespace holder for Kingfisher compatible types.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> kf: <span class="type">KingfisherWrapper</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">KingfisherWrapper</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将-Protocol-加载到所需的-Base-类并通过Extension-where-Base-实现-Base-类的特定代码"><a href="#将-Protocol-加载到所需的-Base-类并通过Extension-where-Base-实现-Base-类的特定代码" class="headerlink" title="将 Protocol 加载到所需的 Base 类并通过Extension + where Base 实现 Base 类的特定代码"></a>将 Protocol 加载到所需的 Base 类并通过Extension + where Base 实现 Base 类的特定代码</h2><p>将我们需要扩展的系统类遵循 protocol，这样对应的 KingfisherWrapper 对象就可以实现对应的系统类里面的方法。</p><p>在实现方法里面有个特别要注意的点，所以 UIImageView 的属性，即可以用 <code>self.</code> 调用的属性都需要变成 <code>base.</code>，因为这边的调用 <code>.kf</code> 的时候每次返回的都是全新的 KingfisherWrapper 实例对象，并不是调用本身对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span>: <span class="title">KingfisherCompatible</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Kingfisher</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIImageView</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(image: UIImage)</span></span> &#123;</span><br><span class="line">        base.image = image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>从上面的分析中来看，这样通过协议命名空间方法实现的 extension 看上去会跟优雅，也能过解决在项目中 manually 方式引入第三方库的时候，出现同名的扩展引起的冲突。但是在扩展的时候我同样发现一个问题，对于 <code>initializers methods</code> 是没办法使用命名空间去扩展的，我们只能对应的给一个 func 返回设置好的 Color 作为返回值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(hex: <span class="type">Int</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> t_alpha = alpha</span><br><span class="line">        <span class="keyword">if</span> t_alpha &lt; <span class="number">0</span> &#123; t_alpha = <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> t_alpha &gt; <span class="number">1</span> &#123; t_alpha = <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> red = (hex &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span></span><br><span class="line">        <span class="keyword">let</span> green = (hex &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">        <span class="keyword">let</span> blue = hex &amp; <span class="number">0xff</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(red: red, green: green, blue: blue, alpha: t_alpha)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2019/05/30/LazySequence/">http://yeziahehe.com/2019/05/30/LazySequence/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在写新项目的时候，在一个下拉组件中看到了 .es 的语法，于是想到了很多的第三库如 Kingfisher, RxSwif
      
    
    </summary>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yeziahehe.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Bye 2017，Hi 2018</title>
    <link href="http://yeziahehe.com/2018/01/02/Bye%202017%EF%BC%8CHi%202018/"/>
    <id>http://yeziahehe.com/2018/01/02/Bye 2017，Hi 2018/</id>
    <published>2018-01-02T03:02:43.000Z</published>
    <updated>2018-01-02T04:54:01.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>又是一年新，三百六十度。仍然记得去年写总结的时候，2017 年算是思想变化很大的一年，有太多的感悟。</p><h1 id="Bye-2017"><a href="#Bye-2017" class="headerlink" title="Bye 2017"></a>Bye 2017</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>在年中离职之后，休息了一段时间，因为苏州互联网的环境，始终没有找到称心如意的工作，于是尝试了 soho。到目前为止，工作了差不多一个季度，工作的内容和企业相差无多，只是一个人在家，规律的作息和工作的安排才是最大的挑战。没有上下班时间的打卡，从头到尾的任务制，如何自律以及如何让自己的情绪保持的很好才是 soho 所面临的最大的问题。soho 的优势在于薪资方面确实比苏州本地的企业要高出很多，时间安排也相对自由；劣势在于不存在企业里面的晋升制度，且没有与人沟通的机会，并且提高自己的效率是个挑战。目前相对来说，我还是比较适应这种模式，初入职场，花时间研究技术以及得到较高的报酬，迅速的积累原始资本，然后合理的投资理财。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>说实话，这一年的技术应该是在退步的。在学校里面，对技术的热情是在工作后无法达到的。工作是要解决生活问题，不可能那么纯粹的去钻研技术，我想以前大学宿舍深夜唱红歌、学技术的时光应该一去不复返了。同样苏州的互联网环境也确实比不上一线城市，室友在寻觅一圈之后，还是选择了脱产读研，我能认同他的想法，这也许是改变现确定性最大的一个选择。考上 985 的研究生，选一个高端的方向，然后努力刷题，进大厂，一样的套路但是确实最能够预见到的。其他的选择，未知性太大，当然同样带来的机遇也会更大。</p><p>移动互联网的浪潮似乎是过了，至少 2017 年的工作岗位明显少，打杂岗位要的人越来越少，高端岗位同样一直在招聘。前几年的培训班搞了一波 iOS，导致这几年 1-3 年的人很难混下去。现在更多的人再聊 AI，可能炒的越火，泡沫越大，这个方向远远没到技术门槛可以下放到整个市场随意招聘的程度。倒是区块链，我觉得未来几年属于可以研究的方向，确实到了爆发的时机了。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今年去了杭州，看了看杭州的互联网环境，也拜访了之前大学最好的室友。今年还和父母一起去了三亚，赶在圣诞节左右，难得的亲子时光。很多年也没有出去旅游了，说实话，和父母亲在一起的更多的是踏实，是内心的一种安稳，与跟其他人在一起的感觉是不一样的。其他零碎的地方我是记不起来了，明年可能会增加更多的出游机会。</p><p>今年年中也住到了自己买的房子里面，与我而言没有什么太大的差别，从来没有租过单间，体验不了别人说的安定。不过房贷的压力，还是让我今年一年减少了很多活动，好在 soho 的 offer 给到后，收入有了明显的提高，年末的三个月没有那么捉襟见肘了。</p><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><p>年末手上积累了一些财富，房贷应该说拿走了我大部分的收入，好在这属于大杠杆，稳赚不赔的生意，也没有什么好后悔的，只是前几年的生活稍微辛苦一些。因为手上积累的一点积蓄，年末开始学习理财知识，也尝试性的购入了股票型、债券型、货币型的基金，属于刚刚入门，慢慢摸索的阶段吧。同时在了解下美股、港股以及评论区永远骂声一片的，明年准备在股市方面也投入一些时间和金钱。</p><h1 id="Hi-2018"><a href="#Hi-2018" class="headerlink" title="Hi 2018"></a>Hi 2018</h1><p>接下来的一年，对自己的要求会更多一些。离开校园有一段时间了，接下来的需要适应社会，而且未来几年也会成立家庭，拥有子女，肩上的担子应该会更重些。</p><h2 id="希望每日能做到的"><a href="#希望每日能做到的" class="headerlink" title="希望每日能做到的"></a>希望每日能做到的</h2><ul><li>早上起来能喝一杯温水</li><li>坚持早睡早起(22:30 ~ 7:30)</li><li>睡前读半小时书</li><li>学习英语</li><li>每周能完成 5 道算法题</li><li>坚持记账</li></ul><h2 id="生活技能"><a href="#生活技能" class="headerlink" title="生活技能"></a>生活技能</h2><ul><li>游泳</li><li>护照</li></ul><h2 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h2><ul><li>东三省</li><li>西安</li><li>加拿大</li></ul><h2 id="理财-1"><a href="#理财-1" class="headerlink" title="理财"></a>理财</h2><ul><li>定投基金，期望年化率 10%</li><li>长期持有中概股，港股腾讯，美股京东、欢聚时代，A 股目前看好中国平安、格力电器、比亚迪</li></ul><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li>未来简史</li><li>国富论</li><li>后续会补上更多…</li></ul><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2018/01/02/Bye">http://yeziahehe.com/2018/01/02/Bye</a> 2017，Hi 2018/</blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;又是一年新，三百六十度。仍然记得去年写总结的时候，2017 年算是思想变化很大的一年，有太多的感悟。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
      <category term="随想" scheme="http://yeziahehe.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="总结" scheme="http://yeziahehe.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2017" scheme="http://yeziahehe.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>Implement strStr()</title>
    <link href="http://yeziahehe.com/2017/11/18/ImplementstrStr/"/>
    <id>http://yeziahehe.com/2017/11/18/ImplementstrStr/</id>
    <published>2017-11-18T11:53:03.000Z</published>
    <updated>2019-03-31T08:45:35.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/ImplementstrStr_error.png" alt></p><p><a href="https://leetcode.com/problems/implement-strstr/description/" target="_blank" rel="noopener">LeetCode 28. Implement strStr()</a>，实现 <code>strStr()</code> 函数，返回子串在字符串中出现的起始位置，未包含则返回 -1。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一开始我用了 Swift 本身语言的特性，如果包含返回 range，取 range 的起始位置即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(<span class="number">_</span> haystack: String, <span class="number">_</span> needle: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !needle.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> range = haystack.range(of: needle) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> range.lowerBound.encodedOffset</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：需要判断子字符串是否为空，是则返回 0；否则会报错如下：</p><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/ImplementstrStr.png" alt></p><p>后来想想这个方法确实投机取巧用了语言的特性，所以还是用算法解决问题，two pointer 的算法思路。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(<span class="number">_</span> haystack: String, <span class="number">_</span> needle: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> needle.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> needle.<span class="built_in">count</span> &gt; haystack.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> haystackChar = <span class="type">Array</span>(haystack)</span><br><span class="line">        <span class="keyword">let</span> needleChar = <span class="type">Array</span>(needle)</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; haystackChar.<span class="built_in">count</span> &#123;</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> haystackChar.<span class="built_in">count</span> - i &lt; needleChar.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;needleChar.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> haystackChar[i + index] == needleChar[index] &#123;</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j == needleChar.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/18/ImplementstrStr/">http://yeziahehe.com/2017/11/18/ImplementstrStr/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yeziahehe.com/tags/Two-Pointers/"/>
    
      <category term="String" scheme="http://yeziahehe.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Roman to Integer</title>
    <link href="http://yeziahehe.com/2017/11/14/RomanToInteger/"/>
    <id>http://yeziahehe.com/2017/11/14/RomanToInteger/</id>
    <published>2017-11-14T15:34:48.000Z</published>
    <updated>2019-03-31T08:36:32.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/RomanToInteger.png" alt></p><p><a href="https://leetcode.com/problems/roman-to-integer/description/" target="_blank" rel="noopener">LeetCode 13. Roman to Integer</a>，题目的意思将罗马数字转换为对应的整数，范围 1~3999。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先肯定先了解下罗马数字的构成规则：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">I</th><th style="text-align:center">V</th><th style="text-align:center">X</th><th style="text-align:center">L</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">M</th></tr></thead><tbody><tr><td style="text-align:center">数字</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">50</td><td style="text-align:center">100</td><td style="text-align:center">500</td><td style="text-align:center">1000</td></tr></tbody></table><ol><li>相同的数字连写，所表示的数等于这些数字相加得到的数，如：Ⅲ = 3；</li><li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：Ⅷ = 8；Ⅻ = 12；</li><li>小的数字，（限于Ⅰ、X 和C）在大的数字的左边，所表示的数等于大数减小数得到的数，如：Ⅳ= 4；Ⅸ= 9；</li><li>正常使用时，连写的数字重复不得超过三次。</li></ol><p>思路很简单，从低位向高位按位转换成整数进行加减。因为不存在违规的罗马数字，所以高位比低位低的则为减，否则则为加。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> pre = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> character <span class="keyword">in</span> s.reversed() &#123;</span><br><span class="line">            <span class="keyword">let</span> int = toInt(character)</span><br><span class="line">            <span class="keyword">if</span> int &lt; pre &#123;</span><br><span class="line">                sum -= int</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += int</span><br><span class="line">            &#125;</span><br><span class="line">            pre = int</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">toInt</span><span class="params">(<span class="number">_</span> character: Character)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> character &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"M"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"L"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"X"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"V"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"I"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/14/RomanToInteger/">http://yeziahehe.com/2017/11/14/RomanToInteger/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yeziahehe.com/tags/Math/"/>
    
      <category term="String" scheme="http://yeziahehe.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Integer to Roman</title>
    <link href="http://yeziahehe.com/2017/11/12/IntegerToRoman/"/>
    <id>http://yeziahehe.com/2017/11/12/IntegerToRoman/</id>
    <published>2017-11-12T15:20:05.000Z</published>
    <updated>2019-03-31T08:43:34.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/IntegerToRoman.png" alt></p><p><a href="https://leetcode.com/problems/integer-to-roman/description/" target="_blank" rel="noopener">LeetCode 12. Integer to Roman</a>，题目的意思将整数转换为对应的罗马数字，范围 1~3999。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先肯定先了解下罗马数字的构成规则：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">I</th><th style="text-align:center">V</th><th style="text-align:center">X</th><th style="text-align:center">L</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">M</th></tr></thead><tbody><tr><td style="text-align:center">数字</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">50</td><td style="text-align:center">100</td><td style="text-align:center">500</td><td style="text-align:center">1000</td></tr></tbody></table><ol><li>相同的数字连写，所表示的数等于这些数字相加得到的数，如：Ⅲ = 3；</li><li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：Ⅷ = 8；Ⅻ = 12；</li><li>小的数字，（限于Ⅰ、X 和C）在大的数字的左边，所表示的数等于大数减小数得到的数，如：Ⅳ= 4；Ⅸ= 9；</li><li>正常使用时，连写的数字重复不得超过三次。</li></ol><h2 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h2><p>很容易想到因为限定了数字范围，不妨按位转换，罗列出个十百千位对应的数字。</p><ul><li><code>M: Nil, M, MM, MMM</code></li><li><code>C: Nil, C, CC, CCC, CD, D, DC, DCC, DCCC, CM</code></li><li><code>X: Nil, X, XX, XXX, XL, L, LX, LXX, LXXX, XC</code></li><li><code>I: Nil, I, II, III, IV, V, VI, VII, VIII, IX</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(<span class="number">_</span> num: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="type">M</span> = [<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>]</span><br><span class="line">        <span class="keyword">let</span> <span class="type">C</span> = [<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>]</span><br><span class="line">        <span class="keyword">let</span> <span class="type">X</span> = [<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>]</span><br><span class="line">        <span class="keyword">let</span> <span class="type">I</span> = [<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">M</span>[num/<span class="number">1000</span>] + <span class="type">C</span>[num/<span class="number">100</span>%<span class="number">10</span>] + <span class="type">X</span>[num/<span class="number">10</span>%<span class="number">10</span>] + <span class="type">I</span>[num%<span class="number">10</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在看过 <code>Discuss</code> 之后发现贪心算法，每次都去减去当前范围最大值。</p><ul><li><code>let int = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]</code></li><li><code>let roman = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(<span class="number">_</span> num: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> val = num</span><br><span class="line">        <span class="keyword">var</span> res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">let</span> int = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> roman = [<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...<span class="number">12</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (val &gt;= int[index]) &#123;</span><br><span class="line">                val -= int[index]</span><br><span class="line">                res += roman[index]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/12/IntegerToRoman/">http://yeziahehe.com/2017/11/12/IntegerToRoman/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yeziahehe.com/tags/Math/"/>
    
      <category term="String" scheme="http://yeziahehe.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Merge Two Sorted Lists</title>
    <link href="http://yeziahehe.com/2017/11/11/MergeTwoSortedLists/"/>
    <id>http://yeziahehe.com/2017/11/11/MergeTwoSortedLists/</id>
    <published>2017-11-11T14:45:42.000Z</published>
    <updated>2019-03-31T08:44:37.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/MergeTwoSortedLists.png" alt></p><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">LeetCode 21. Merge Two Sorted Lists</a>，题目的意思就是合并链表。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>其实很简单的思路就是不停的比较两个链表中的元素大小，然后依次插入即可。刚刚开始写了很冗长的判断，后来看了 <code>Discuss</code> 递归的方式，原理一致，代码更加简洁。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">ListNode?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.next = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(<span class="number">_</span> l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode?</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1!.val &lt; l2!.val &#123;</span><br><span class="line">            l1?.next = mergeTwoLists(l1?.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2?.next = mergeTwoLists(l1, l2?.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/11/MergeTwoSortedLists/">http://yeziahehe.com/2017/11/11/MergeTwoSortedLists/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yeziahehe.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Plus One</title>
    <link href="http://yeziahehe.com/2017/11/07/PlusOne/"/>
    <id>http://yeziahehe.com/2017/11/07/PlusOne/</id>
    <published>2017-11-07T13:09:54.000Z</published>
    <updated>2019-03-31T08:35:01.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/PlusOne.png" alt></p><p><a href="https://leetcode.com/problems/plus-one/description/" target="_blank" rel="noopener">LeetCode 66. Plus One</a>，题目的意思给定一个非负数组表示一个数字，从高位向低位排，加一之后输出结果。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先把数组反向然后遍历，如果是 <code>index == 0</code> 就加一，记录下进位值 <code>carry = sum / 10</code> 和加一后的当前数字 <code>reDigits[index] = sum % 10</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(<span class="number">_</span> digits: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> reDigits: [<span class="type">Int</span>] = digits.reversed()</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (index, digit) <span class="keyword">in</span> reDigits.enumerated() &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = index == <span class="number">0</span> ? digit + <span class="number">1</span> + carry : digit + carry</span><br><span class="line">            carry = sum / <span class="number">10</span></span><br><span class="line">            reDigits[index] = sum % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">            reDigits.append(carry)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reDigits.reversed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/07/PlusOne/">http://yeziahehe.com/2017/11/07/PlusOne/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yeziahehe.com/tags/Math/"/>
    
      <category term="Array" scheme="http://yeziahehe.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="http://yeziahehe.com/2017/11/06/ReverseLinkedList/"/>
    <id>http://yeziahehe.com/2017/11/06/ReverseLinkedList/</id>
    <published>2017-11-06T11:57:00.000Z</published>
    <updated>2019-03-31T08:35:54.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/ReverseLinkedList.png" alt></p><p><a href="https://leetcode.com/problems/reverse-linked-list/description/#" target="_blank" rel="noopener">LeetCode 206. Reverse Linked List</a>，反转链表，迭代法和递归法同时实现。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>迭代的精髓在于按顺序对指针指向的扭转。以1-&gt;2-&gt;3-&gt;4为例，当迭代到第三次时，前面的运算已经保存了一个pre值，值为2-&gt;1，这时到3这个节点，只需把它的指向指到pre即可，而构成的新的链表3-&gt;2-&gt;1保存为pre以供下次迭代，但是因为它后面的值还要做运算，所以把它原先的指向先保存起来（为next），为了下次继续迭代。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(<span class="number">_</span> head: ListNode?)</span></span> -&gt; <span class="type">ListNode?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> || head?.next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> headNode = head</span><br><span class="line">        <span class="keyword">var</span> pre: <span class="type">ListNode?</span> = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">while</span> (headNode != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = headNode?.next</span><br><span class="line">            headNode?.next = pre</span><br><span class="line">            pre = headNode</span><br><span class="line">            headNode = tmp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>递归的精髓在于将next当做参数传入reverseList函数时，在下一次递归中对参数的操作，会反应在上次的参数值上。<br>还是以1-&gt;2-&gt;3-&gt;4举例子，4次递归后（回溯前），其实是将引用链全部打破：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(<span class="number">_</span> head: ListNode?)</span></span> -&gt; <span class="type">ListNode?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> || head?.next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> next = head?.next</span><br><span class="line">        head?.next = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">let</span> newHead = reverseList(next)</span><br><span class="line">        next?.next = head</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/06/ReverseLinkedList/">http://yeziahehe.com/2017/11/06/ReverseLinkedList/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yeziahehe.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Find K Pairs with Smallest Sums</title>
    <link href="http://yeziahehe.com/2017/11/05/FindKPairsWithSmallestSums/"/>
    <id>http://yeziahehe.com/2017/11/05/FindKPairsWithSmallestSums/</id>
    <published>2017-11-05T13:03:51.000Z</published>
    <updated>2019-03-31T08:45:43.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/FindKPairsWithSmallestSums.png" alt></p><p><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/" target="_blank" rel="noopener">LeetCode 373. Find K Pairs with Smallest Sums</a>，题目的意思给定两个升序排序整数数组，从两个数组中各取一个数字组合成 (u,v)，输出前 k 个最小的组合。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我原本想定义一套判断规则，但是发现要处理很多下标情况。后来看了 Discuss 之后，最好的方式是定义 Heap（堆数据结构），但是 Swift 中不包含这样的数据结构。退而求其次，用了一个方法，记录 nums1 中每个元素已经配对到 nums2 中的第几个，每次遍历 nums1 中的元素，求出 <code>nums1[i]+nums2[index[i]]</code>，取出最小值放入输出数组中即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">kSmallestPairs</span><span class="params">(<span class="number">_</span> nums1: [Int], <span class="number">_</span> nums2: [Int], <span class="number">_</span> k: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">if</span> k &lt;= <span class="number">0</span> || nums1.isEmpty || nums2.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cnt = <span class="built_in">min</span>(k, nums1.<span class="built_in">count</span> * nums2.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">var</span> index = <span class="type">Array</span>(repeatElement(<span class="number">0</span>, <span class="built_in">count</span>: nums1.<span class="built_in">count</span>))</span><br><span class="line">        <span class="keyword">var</span> pairs: [[<span class="type">Int</span>]] = []</span><br><span class="line">        <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> n &lt; cnt &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">min</span> = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">            <span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums1.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> index[i] &lt; nums2.<span class="built_in">count</span> &amp;&amp; nums1[i]+nums2[index[i]] &lt; <span class="built_in">min</span> &#123;</span><br><span class="line">                    <span class="built_in">min</span> = nums1[i]+nums2[index[i]]</span><br><span class="line">                    m = i</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pairs.append([nums1[m], nums2[index[m]]])</span><br><span class="line">            index[m] += <span class="number">1</span></span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pairs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/05/FindKPairsWithSmallestSums/">http://yeziahehe.com/2017/11/05/FindKPairsWithSmallestSums/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Heap" scheme="http://yeziahehe.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Product of Three Numbers</title>
    <link href="http://yeziahehe.com/2017/11/03/MaximumProductOfThreeNumbers/"/>
    <id>http://yeziahehe.com/2017/11/03/MaximumProductOfThreeNumbers/</id>
    <published>2017-11-03T08:56:28.000Z</published>
    <updated>2019-03-31T08:44:19.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/MaximumProductOfThreeNumber.png" alt></p><p><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="noopener">LeetCode 628. Maximum Product of Three Numbers</a>，题目的意思是在一个给定范围的整数数组里面寻找三个数积最大值。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>思路上面很清晰，三个最大数或者两个最小数和最大数，比较这两个值中较大的一个，则为最大值。</p><h2 id="第一种（没通过）"><a href="#第一种（没通过）" class="headerlink" title="第一种（没通过）"></a>第一种（没通过）</h2><p>先使用系统的排序函数排序，时间复杂度上没通过。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maximumProduct</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sortNums = nums.sorted()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sortNums[<span class="number">0</span>] * sortNums[<span class="number">1</span>] * sortNums[nums.<span class="built_in">count</span> - <span class="number">1</span>], sortNums[nums.<span class="built_in">count</span> - <span class="number">3</span>] * sortNums[nums.<span class="built_in">count</span> - <span class="number">2</span>] * sortNums[nums.<span class="built_in">count</span> - <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity Analysis</p><ul><li>Time complexity : O(nlog(n)). Sorting the numsnums array takes nlog(n) time.</li><li>Space complexity : O(log(n)). Sorting takes O(logn) space.</li></ul><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/MaximumProductOfThreeNumbers_error.png" alt></p><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>遍历数组，记录上述所需要的 5 个值，然后进行比较。时间复杂度为数组长度 O(n)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maximumProduct</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> min1 = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">        <span class="keyword">var</span> min2 = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">        <span class="keyword">var</span> max1 = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">var</span> max2 = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">var</span> max3 = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> num &lt;= min1 &#123;</span><br><span class="line">                min2 = min1</span><br><span class="line">                min1 = num</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt;= min2 &#123;</span><br><span class="line">                min2 = num</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> num &gt;= max1 &#123;</span><br><span class="line">                max3 = max2</span><br><span class="line">                max2 = max1</span><br><span class="line">                max1 = num</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt;= max2 &#123;</span><br><span class="line">                max3 = max2</span><br><span class="line">                max2 = num</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt;= max3 &#123;</span><br><span class="line">                max3 = num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(min1 * min2 * max1, max1 * max2 * max3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity Analysis</p><ul><li>Time complexity : O(n). Only one iteration over the numsnums array of length nn is required.</li><li>Space complexity : O(1). Constant extra space is used.</li></ul><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/03/MaximumProductOfThreeNumbers/">http://yeziahehe.com/2017/11/03/MaximumProductOfThreeNumbers/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yeziahehe.com/tags/Math/"/>
    
      <category term="Array" scheme="http://yeziahehe.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Convert Sorted Array to Binary Search Tree</title>
    <link href="http://yeziahehe.com/2017/11/02/ConvertSortedArrayToBinarySearchTree/"/>
    <id>http://yeziahehe.com/2017/11/02/ConvertSortedArrayToBinarySearchTree/</id>
    <published>2017-11-02T11:52:05.000Z</published>
    <updated>2019-03-31T08:46:49.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/ConvertSortedArraytoBinarySearchTree.png" alt></p><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener">LeetCode 108. Convert Sorted Array to Binary Search Tree</a>，题目的意思将一个升序的数组转化为平衡二叉查找树。</p><h2 id="balanced-BST"><a href="#balanced-BST" class="headerlink" title="balanced BST"></a>balanced BST</h2><p>二叉查找树（BST）是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。具体的说，就是使用每个节点含有两个链接（链表中每个节点只含有一个链接）的二叉查找树来高效地实现符号表。我们定义的数据结构由 <strong>结点</strong> 组成，结点包含的链接可以为空或者指向其他结点。在二叉树中，每个节点只能有一个父节点（只有一个例外，也就是根节点，它没有父节点），而且每个节点都只有左右两个链接，分别指向自己的左子节点和右子节点。二叉查找树的数据结构如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">TreeNode?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">TreeNode?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">left</span> = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">right</span> = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，对于一般的二叉搜索树，其期望高度（即为一棵平衡树时）为lgn，其各操作的时间复杂度 O(lgn) 同时也由此而决定，这样就和二分查找时间复杂度一致。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们在平时构造二叉搜索树的时候，会通过随机化建立二叉搜索树，来避免这种情况，但是这种距离平衡二叉搜索树的时间复杂度还是有一定的差距。平衡二叉搜索树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。不幸的是，在动态插入中保证树的完美平衡的代价太高了，相应的就有红黑二叉数等算法改进，这里不做过多介绍。</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>因为是有序的数组，所以可以直接通过二分的方法来不断的进行递归插入。联想到二分方法的原因是，因为二分法的时间复杂度为 O(lgn)，而平衡二叉查找树的时间复杂度也为 O(lgn)。所以算法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">TreeNode?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortSubArrayToBST(nums, <span class="number">0</span>, nums.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sortSubArrayToBST</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> strat: Int, <span class="number">_</span> end: Int)</span></span> -&gt; <span class="type">TreeNode?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> strat &lt;= end <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mid = (strat + end) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">TreeNode</span>(nums[mid])</span><br><span class="line">        node.<span class="keyword">left</span> = sortSubArrayToBST(nums, strat, mid - <span class="number">1</span>)</span><br><span class="line">        node.<span class="keyword">right</span> = sortSubArrayToBST(nums, mid + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/11/02/ConvertSortedArrayToBinarySearchTree/">http://yeziahehe.com/2017/11/02/ConvertSortedArrayToBinarySearchTree/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yeziahehe.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="http://yeziahehe.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Gap</title>
    <link href="http://yeziahehe.com/2017/10/16/MaximumGap/"/>
    <id>http://yeziahehe.com/2017/10/16/MaximumGap/</id>
    <published>2017-10-16T11:52:05.000Z</published>
    <updated>2019-03-31T08:43:59.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/MaximumGap.png" alt></p><p><a href="https://leetcode.com/problems/maximum-gap/description/" target="_blank" rel="noopener">LeetCode 164. Maximum Gap</a>，题目的意思给定一个未排序的数组，找到在排序情况下相邻两个数最大差值。要在线性时间和空间内解决，&lt; 2 个元素返回 0。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先想到的是利用系统的 sort() 进行排序，但是明显超时。最大的差值肯定大于 <code>(maxValue - minValue) / (nums.count - 1)</code>，很容易想到桶排序（当然我没想到，看了 Discuss 之后才想到）。那么令桶空间为 <code>(maxValue - minValue) / (nums.count - 1)</code>。排序完成后，只需要依次将相邻桶空间，后空间最小值减去前空间的最大值，然后寻找其中的最大值。</p><p>PS：</p><ol><li>桶空间 <code>max(1, (maxValue - minValue) / (nums.count - 1))</code>，处理最大值和最小相等、差值比个数小太多的情况。</li><li>桶个数 <code>(maxValue - minValue) / bucketCount + 1</code>，极限值[1, 10000000]。</li><li><code>preBucketMax</code> 记录前空间的最大值，因为有可能后一个桶空间为空。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">var</span> empty: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">var</span> maxValue: <span class="type">Int</span> = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">var</span> minValue: <span class="type">Int</span> = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maximumGap</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums.isEmpty || nums.<span class="built_in">count</span> &lt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> maxValue = nums.<span class="built_in">max</span>()!, minValue = nums.<span class="built_in">min</span>()!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> bucketCount = <span class="built_in">max</span>(<span class="number">1</span>, (maxValue - minValue) / (nums.<span class="built_in">count</span> - <span class="number">1</span>))<span class="comment">//处理最大值和最小相等、差值比个数小太多的情况</span></span><br><span class="line">        <span class="keyword">let</span> bucketNum = (maxValue - minValue) / bucketCount + <span class="number">1</span><span class="comment">//极限值[1, 10000000]</span></span><br><span class="line">        <span class="keyword">var</span> buckets = <span class="type">Array</span>(repeatElement(<span class="type">Bucket</span>(), <span class="built_in">count</span>: bucketNum))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line">            <span class="keyword">let</span> index = (num - minValue) / bucketCount</span><br><span class="line">            buckets[index].empty = <span class="literal">false</span></span><br><span class="line">            buckets[index].maxValue = <span class="built_in">max</span>(num, buckets[index].maxValue)</span><br><span class="line">            buckets[index].minValue = <span class="built_in">min</span>(num, buckets[index].minValue)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> preBucketMax = minValue, maxGap: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets &#123;</span><br><span class="line">            <span class="keyword">if</span> bucket.empty &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxGap = <span class="built_in">max</span>(bucket.minValue - preBucketMax, maxGap)</span><br><span class="line">            preBucketMax = bucket.maxValue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxGap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/10/16/MaximumGap/">http://yeziahehe.com/2017/10/16/MaximumGap/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Sort" scheme="http://yeziahehe.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Word Break II</title>
    <link href="http://yeziahehe.com/2017/10/15/WordBreakII/"/>
    <id>http://yeziahehe.com/2017/10/15/WordBreakII/</id>
    <published>2017-10-15T11:52:05.000Z</published>
    <updated>2019-03-31T08:41:26.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/WordBreakII.png" alt></p><p><a href="https://leetcode.com/problems/word-break-ii/description/" target="_blank" rel="noopener">LeetCode 140. Word Break II</a>，题目的意思原题的意思给定一个非空的字符串和非空的单词字典（不包含重复元素），将所有可能的分割方式用数组输出。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>记忆化搜索，在搜索过程中，使用字典tokenDict将已经搜索过的子句的拆解方案记录下来，从而实现DFS的剪枝。</p><p>时间复杂度 O(n²)，空间复杂度 O(n²)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> wordDict: [String])</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> cache = [<span class="type">String</span>: [<span class="type">String</span>]]()</span><br><span class="line">        <span class="keyword">return</span> <span class="type">DFS</span>(s, wordDict, &amp;cache)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">DFS</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> wordDict: [String], <span class="number">_</span> cache: <span class="keyword">inout</span> [String: [String]])</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> s.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">""</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> value = cache[s] &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict &#123;</span><br><span class="line">            <span class="keyword">if</span> s.hasPrefix(word) &#123;</span><br><span class="line">                <span class="keyword">let</span> subWordBreaks = <span class="type">DFS</span>(<span class="type">String</span>(s.suffix(from: word.endIndex)), wordDict, &amp;cache)</span><br><span class="line">                <span class="keyword">for</span> subWordBreak <span class="keyword">in</span> subWordBreaks &#123;</span><br><span class="line">                    <span class="keyword">if</span> subWordBreak.isEmpty &#123;</span><br><span class="line">                        result.append(word)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.append(word + <span class="string">" "</span> + subWordBreak)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[s] = result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/10/15/WordBreakII/">http://yeziahehe.com/2017/10/15/WordBreakII/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yeziahehe.com/tags/Dynamic-Programming/"/>
    
      <category term="Backtracking" scheme="http://yeziahehe.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Word Break</title>
    <link href="http://yeziahehe.com/2017/10/14/WordBreak/"/>
    <id>http://yeziahehe.com/2017/10/14/WordBreak/</id>
    <published>2017-10-14T11:52:05.000Z</published>
    <updated>2019-03-31T08:40:21.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/WordBreak.png" alt></p><p><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">LeetCode 139. Word Break</a>，原题的意思给定一个非空的字符串和非空的单词字典（不包含重复元素），判断字符串是否可以被分割成字典中的一个或者多个单词。</p><p>这题有进阶的题目，题解 <a href="http://yeziahehe.com/2017/10/15/WordBreakII/">Word Break II</a>。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一题典型的动态规划，如果一个单词存在一种分解方法，分解后每一单词都应该在字典中，那必定满足一个条件：对于该单词的最后一个分割点，分割点到单词末尾的字符串是一个单词，而这个分割点到单词开头所组成的字符串也是可分解的。所以只要验证满足这个条件，我们则可以确定字符串是可分解的。</p><ol><li>用外层循环来控制待验证的字符串的长度，而用内层的循环来寻找这么一个分割点，可以把字符串分成一个单词和一个同样可分解的子字符串。</li><li>同时，我们用数组记录下字符串长度递增时可分解的情况，以供之后使用，避免重复计算。用 Bool wordArray[i] 表示到字符串 s 的第 i 个字符时，是否可以用 wordDict 中的单词来表示。</li><li>假设有 wordArray[0…i-1] 的结果，那么 wordArray[i] 的值应该是：wordArray[i] = wordArray[j] &amp;&amp; s.substring(j, i) in wordDict，其中 j 属于[0…i-1]。</li></ol><p>时间复杂度 O(n²)，空间复杂度 O(n)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> wordDict: [String])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> wordDict.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> wordArray = <span class="type">Array</span>.<span class="keyword">init</span>(repeating: <span class="literal">false</span>, <span class="built_in">count</span>: s.<span class="built_in">count</span> + <span class="number">1</span>)</span><br><span class="line">        wordArray[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...s.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">stride</span>(from: i-<span class="number">1</span>, through: <span class="number">0</span>, by: -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> wordArray[j] &amp;&amp; wordDict.<span class="built_in">contains</span>(<span class="type">String</span>(s[s.index(s.startIndex, offsetBy: j)..&lt;s.index(s.startIndex, offsetBy: i)])) &#123;</span><br><span class="line">                    wordArray[i] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wordArray[s.<span class="built_in">count</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/10/14/WordBreak/">http://yeziahehe.com/2017/10/14/WordBreak/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Dynamic Programming" scheme="http://yeziahehe.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Move Zeroes</title>
    <link href="http://yeziahehe.com/2017/10/13/MoveZeroes/"/>
    <id>http://yeziahehe.com/2017/10/13/MoveZeroes/</id>
    <published>2017-10-13T11:52:05.000Z</published>
    <updated>2019-03-31T08:40:00.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/MoveZeroes.png" alt></p><p><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">LeetCode 283. Move Zeroes</a>，题目的意思在不复制数组的情况下，用最少的操作将 0 移到最后。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一个移动的 i pointer（初始值为 0），遍历数组发现非 0 元素，则将对应 i 的元素赋值为当前遍历的值。遍历完成后，比较 i 和数组长度，将剩余元素复制为 0 即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(<span class="number">_</span> nums: <span class="keyword">inout</span> [Int])</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> num != <span class="number">0</span> &#123;</span><br><span class="line">                nums[i] = num</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; nums.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> zeroIndex <span class="keyword">in</span> i..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">                nums[zeroIndex] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/10/13/MoveZeroes/">http://yeziahehe.com/2017/10/13/MoveZeroes/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yeziahehe.com/tags/Two-Pointers/"/>
    
      <category term="Array" scheme="http://yeziahehe.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Longest Substring Without Repeating Characters</title>
    <link href="http://yeziahehe.com/2017/10/11/LongestSubstringWithoutRepeatingCharacters/"/>
    <id>http://yeziahehe.com/2017/10/11/LongestSubstringWithoutRepeatingCharacters/</id>
    <published>2017-10-11T11:52:05.000Z</published>
    <updated>2019-03-31T08:43:48.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/LongestSubstringWithoutRepeatingCharacters.png" alt></p><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">LeetCode 3. Longest Substring Without Repeating Characters</a>，题目的意思寻找 String 中元素不重复的最长子序列。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这一题我使用的 Two Pointers 的算法，使用了 start 和 end 两个指针，右指针不断的进行右移，没有发现重复元素的情况下，遍历区间内有没有相似元素，如果有直接左指针变为 i+1。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> array = <span class="type">Array</span>(s)</span><br><span class="line">        <span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">right</span> &lt; array.<span class="built_in">count</span> &#123;</span><br><span class="line">            i = <span class="keyword">left</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> array[i] == array[<span class="keyword">right</span>] &#123;</span><br><span class="line">                    <span class="keyword">left</span> = i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            length = <span class="built_in">max</span>(length, <span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">right</span> += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/10/11/LongestSubstringWithoutRepeatingCharacters/">http://yeziahehe.com/2017/10/11/LongestSubstringWithoutRepeatingCharacters/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yeziahehe.com/tags/Two-Pointers/"/>
    
      <category term="String" scheme="http://yeziahehe.com/tags/String/"/>
    
      <category term="Hash Table" scheme="http://yeziahehe.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Add Two Numbers</title>
    <link href="http://yeziahehe.com/2017/10/10/AddTwoNumbers/"/>
    <id>http://yeziahehe.com/2017/10/10/AddTwoNumbers/</id>
    <published>2017-10-10T11:52:05.000Z</published>
    <updated>2019-03-31T08:47:55.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/AddTwoNumbers.png" alt></p><p><a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">LeetCode 2. Add Two Numbers</a>，题目的意思用两个非空的链表来表示两个非负整数，且链表顺序为数字倒序，求出两个数之和，返回和对应的链表。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>按位进行逐位相加，需要主要的是进位记录，以及两个数位数不匹配的情况下的计算。首先定义链表 Node 数据结构如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">ListNode?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.next = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 headNode 作为初始值，循环相加，注意边界情况，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(<span class="number">_</span> l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> headNode = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> p = l1, q = l2, curr = headNode</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nil</span> || q != <span class="literal">nil</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> x = (p != <span class="literal">nil</span>) ? p!.val : <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span> y = (q != <span class="literal">nil</span>) ? q!.val : <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span> sum = x + y + carry</span><br><span class="line">            carry = sum / <span class="number">10</span></span><br><span class="line">            curr.next = <span class="type">ListNode</span>(sum % <span class="number">10</span>)</span><br><span class="line">            curr = curr.next!</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nil</span>) &#123;</span><br><span class="line">                p = p!.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">nil</span>) &#123;</span><br><span class="line">                q = q!.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode.next!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/10/10/AddTwoNumbers/">http://yeziahehe.com/2017/10/10/AddTwoNumbers/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yeziahehe.com/tags/Linked-List/"/>
    
      <category term="Math" scheme="http://yeziahehe.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum</title>
    <link href="http://yeziahehe.com/2017/10/09/TwoSum/"/>
    <id>http://yeziahehe.com/2017/10/09/TwoSum/</id>
    <published>2017-10-08T16:09:12.000Z</published>
    <updated>2019-03-31T08:31:10.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/TwoSum.jpg" alt></p><p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">LeetCode 1. Two Sum</a>，题目的意思简单来说就是给 Target，从数组中找到两个数和，同一个数不可以用两次，且我在测试的时候发现会有同一个值出现两次的情况。</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>很简单的方式，两个 for loop 就能解决，时间复杂度为 O(n²)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表，Table Hash。这边只是很简单的应用，后续会介绍更加复杂的应用。简单的思想就是将数组中的数不断的读入，key - 是数组中的值，value - 是遍历数组的 index。写入的时候先判断 Target - nums[i] 的 key 是否存在 value。如果存在说明这个数已经被写入了，那么就找到了这两个数；如果不存在则写入数组。算法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> dictionary = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> item = dictionary[target - nums[i]] &#123;</span><br><span class="line">                <span class="keyword">return</span> [item, i]</span><br><span class="line">            &#125;</span><br><span class="line">            dictionary[nums[i]] = i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 本来没打算写这篇博客，主要是我朋友在写这一条的写了 Python 算法，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            a = target - item</span><br><span class="line">            list = copy.copy(nums)</span><br><span class="line">            <span class="keyword">del</span> list[index]</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> list:</span><br><span class="line">                <span class="keyword">if</span> nums.index(a) == index:</span><br><span class="line">                    <span class="keyword">return</span> [index,list.index(a)+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">return</span> [index, nums.index(a)]</span><br></pre></td></tr></table></figure><p>简单的来看，是读取一个数首先删除本身，然后去判断 target - item 是不是存在数组中。我开始很疑惑，在没有使用散列表的情况下，只用数组解出来一定是牺牲了时空复杂度。果然问题在 <code>if a in list:</code>，python 的语法糖在做这句话的时候，其实是做了 For loop，所以时间复杂度为 O(n²)。迷惑了我朋友很久才想通的问题，大家在刷题的时候一定要注意：<strong>高级语言的语法糖和数据结构在带来遍历的同时，在处理方式上面可能会存在你不知道的时空耗费。</strong></p><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/10/09/TwoSum/">http://yeziahehe.com/2017/10/09/TwoSum/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1258094708.cos.ap-shanghai.myqcloud.com
      
    
    </summary>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="Hash Table" scheme="http://yeziahehe.com/tags/Hash-Table/"/>
    
      <category term="Array" scheme="http://yeziahehe.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>算法学习 - 最大子数组问题 [Maximum Subarray]</title>
    <link href="http://yeziahehe.com/2017/09/21/MaximumSubArray/"/>
    <id>http://yeziahehe.com/2017/09/21/MaximumSubArray/</id>
    <published>2017-09-21T09:34:54.000Z</published>
    <updated>2019-03-31T09:00:59.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h1><p>在实际生活中，通常会出现一个场景，炒股的人盯着一只股票涨跌情况在分析这只股票一段时间内，何时买进买出才能达到收益的最大化。通常人们想到的是“低价买进，高价卖出”，这是最理想的情况，但是实际情况中，你可能无法做到。比如下图中股票 A，最高价格出现在第 0 天，而最低价格出现在第 3 天，显然无法做到低买高卖。于是你可能会想也许满足其中的任意一个条件，得到的结果就是最优结果。不否认，股票 A 如果在第 3 天最低价的时候买进，确实能达到收益最大化。但是股票 B 给出了一个反例，最大收益既不是在最低价格时买进，也不是在最高价格时卖出。</p><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/real_pic.png" alt="股票情况"></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们想找到收益最大化的方法，其实可以换一个角度来看数据。我们是想寻找一段日期，在日期范围内股票价格的净变化值最大，所以可以考察每日价格变化的差价，第 i 天的价格差价为第 i 天和第 i-1 天的价格差，如下表所示，那么把这个看成数组，问题就转化成寻找数组的 <strong>和最大的非空连续子数组</strong>。我们称这样的连续子数组为 <strong>最大子数组</strong>（maximum subarray）。</p><table><thead><tr><th style="text-align:center">天数</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th>4</th></tr></thead><tbody><tr><td style="text-align:center">差值</td><td style="text-align:center">-30</td><td style="text-align:center">20</td><td style="text-align:center">-50</td><td>30</td></tr></tbody></table><p>虽然做了变换，但是对于 n 天的日期，通过暴力求解的方式，所需要的时间复杂度仍然为 O(n²)。</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>刚刚讲过，通过暴力求解的方式，并不能降低时间复杂度。算法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxSum = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">                sum += nums[j]</span><br><span class="line">                maxSum = <span class="built_in">max</span>(sum, maxSum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路上面很简单，其实用枚举法把所有子数组的和全部算出来进行比较，然后选出其中最大的。在 <a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">LeetCode 53. Maximum Subarray</a> 上提交，会出现 <code>Submission Result: Time Limit Exceeded</code>，显然时间复杂度太高。</p><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/submission1.png" alt="Time Limit Exceeded"></p><h2 id="分治策略求解"><a href="#分治策略求解" class="headerlink" title="分治策略求解"></a>分治策略求解</h2><p>分治策略，最常见的实际应用就是归并排序。说到分治策略，就是递归地求解一个问题。在每层递归中分三个步骤解决问题：</p><ul><li><strong>分解（Devide）</strong>，将问题划分为相同的子问题；</li><li><strong>解决（Conquer）</strong>，求解子问题，如果达到条件直接求解，未达到条件则继续递归；</li><li><strong>合并（Combine）</strong>，将子问题的解合成原问题的解。</li></ul><p>递归的计算方式有通用公式：T(n) = aT(n/b) + f(n)。</p><p>最大子数组每次都是最数组进行二等分，所以公式为：T(n) = 2T(n/2) + f(n)，那么时间复杂度就是 O(nlgn)。</p><p>我们要通过分治策略来寻找数组 A[low..high] 的最大子数组，意味着我们要将子数组划分为两个规模相等的子数组。首先找到子数组的中央位置 mid，然后考虑求解两个子数组 A[low..mid] 和 A[mid+1..high]。我们很容易发现最大子数组 A[i..j] 所处的位置必然是以下情况之一：</p><ul><li>完全位于子数组 A[low..mid] 中，那么 low ≤ i ≤ j ≤ mid。</li><li>完全位于子数组 A[mid+1..high] 中，那么 mid &lt; i ≤ j ≤ high。</li><li>子数组跨越了中点，那么 low ≤ i ≤ mid &lt; j ≤ high。</li></ul><p><img src="https://blog-1258094708.cos.ap-shanghai.myqcloud.com/subarray_pic.png" alt="图示"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxCrossingSubSum</span><span class="params">(<span class="number">_</span> subArray: [Int], <span class="number">_</span> <span class="keyword">left</span>: Int, <span class="number">_</span> mid: Int, <span class="number">_</span> <span class="keyword">right</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxLeftSum = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">var</span> maxRightSum = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="keyword">left</span>...mid).reversed() &#123;</span><br><span class="line">            sum += subArray[i]</span><br><span class="line">            maxLeftSum = <span class="built_in">max</span>(sum, maxLeftSum)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> mid+<span class="number">1</span>...<span class="keyword">right</span> &#123;</span><br><span class="line">            sum += subArray[i]</span><br><span class="line">            maxRightSum = <span class="built_in">max</span>(sum, maxRightSum)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLeftSum + maxRightSum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxSubSum</span><span class="params">(<span class="number">_</span> subArray: [Int], <span class="number">_</span> <span class="keyword">left</span>: Int, <span class="number">_</span> <span class="keyword">right</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">left</span> == <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> subArray[<span class="keyword">left</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mid = (<span class="keyword">left</span> + <span class="keyword">right</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> maxLeftSum = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">var</span> maxRightSum = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">var</span> maxMidSum = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line"></span><br><span class="line">        maxLeftSum = maxSubSum(subArray, <span class="keyword">left</span>, mid)</span><br><span class="line">        maxRightSum = maxSubSum(subArray, mid + <span class="number">1</span>, <span class="keyword">right</span>)</span><br><span class="line">        maxMidSum = maxCrossingSubSum(subArray, <span class="keyword">left</span>, mid, <span class="keyword">right</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxLeftSum, maxRightSum, maxMidSum)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSubSum(nums, <span class="number">0</span>, nums.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h2><p>动态规划（dynamic programming）与分治策略相似，这里的 programming 指的是一种表格法，都是通过组合子问题的解来求解原问题。分治法将问题划分为互不相交的子问题，递归的求解子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于 <strong>子问题重叠</strong> 的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治策略会做许多不必要的工作，它会反复的求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的工作。</p><p>动态规划方法通常用来求解 <strong>最优化问题</strong>，这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。</p><p>通常按照 4 个步骤来设计动态规划算法：</p><ul><li>寻找一个最优解的结构特征。</li><li>递归的定义最优解的值。</li><li>计算最优解的值，通常采用自底向上的方法。</li><li>利用计算出的信息构造一个最优解。</li></ul><p>最大子数组里面，我们首先要想清楚一个问题就是对于 maxSubArray(A, i) 来说，如果它是目前最大的数组，那么子数组 maxSubArray(A, i - 1) 一定是非负数，因为 maxSubArray(A, i - 1) &gt; maxSubArray(A, i - 1) + A[i]，所以不难得出一个结论：<code>maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) + A[i] : A[i];</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> maxSum = <span class="type">Int</span>.<span class="built_in">min</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line">            sum = <span class="built_in">max</span>(num, sum + num)</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, sum)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：动态规划这一部分稍后会详细的博客讲解。</p><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/09/21/MaximumSubArray/">http://yeziahehe.com/2017/09/21/MaximumSubArray/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实际场景&quot;&gt;&lt;a href=&quot;#实际场景&quot; class=&quot;headerlink&quot; title=&quot;实际场景&quot;&gt;&lt;/a&gt;实际场景&lt;/h1&gt;&lt;p&gt;在实际生活中，通常会出现一个场景，炒股的人盯着一只股票涨跌情况在分析这只股票一段时间内，何时买进买出才能达到收益的最大化。通
      
    
    </summary>
    
      <category term="算法" scheme="http://yeziahehe.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode OJ" scheme="http://yeziahehe.com/categories/%E7%AE%97%E6%B3%95/LeetCode-OJ/"/>
    
    
      <category term="算法" scheme="http://yeziahehe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yeziahehe.com/tags/LeetCode/"/>
    
      <category term="最大子数组" scheme="http://yeziahehe.com/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
      <category term="枚举" scheme="http://yeziahehe.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="分治策略" scheme="http://yeziahehe.com/tags/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"/>
    
      <category term="动态规划" scheme="http://yeziahehe.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>详解 Swift 中 class 和 struct</title>
    <link href="http://yeziahehe.com/2017/09/11/class_struct_enum/"/>
    <id>http://yeziahehe.com/2017/09/11/class_struct_enum/</id>
    <published>2017-09-11T10:14:52.000Z</published>
    <updated>2017-11-03T05:47:13.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Swift 中 struct、enum 都有了很大的变化，这边从基本概念开始分析，如值类型和引用类型的原理、内存管理机制等等来分析三者在 Swift 语言中的异同。</p><h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><p>首先提到的是 iOS 中的内存管理机制的问题，在 iOS 中内存对象主要有两类，值类型和引用类型。值类型就是 int、float、struct、enum、tuple 等基本数据类型，引用类型就是继承自 NSObject 的对象，通常是类对象，我们做内存管理的时候就是对这种对象进行管理。</p><p><strong>为什么值类型不需要进行内存管理，而引用类型需要进行内存管理呢？</strong> 因为两种方式的内存分配机制不一样，值类型存储在栈当中，在内存中连续的内存空间，遵循后进先出（LIFO）的原则；而引用类型存储在堆当中，存储空间是随机的，对象之间留有空白空间，会产生空间碎片，需要手动进行管理。</p><h2 id="有什么区别？"><a href="#有什么区别？" class="headerlink" title="有什么区别？"></a>有什么区别？</h2><p>值类型基本特征就是复制数据，不管是在赋值、初始化还是参数传递的过程中，并且为这个数据创建独立的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">var</span> b = a<span class="comment">// a被复制给了b</span></span><br><span class="line">a.value = <span class="number">1</span><span class="comment">// a改变了, b没有</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"\(a.value), \(b.value)"</span>)<span class="comment">// "0, 1"</span></span><br></pre></td></tr></table></figure><p>引用类型在赋值、初始化还是参数传递的过程中其实创建了实例，但是实例的指针指向和原来实例同样的内存地址，所以说修改其中一个示例数据的时候，另一个实例数据也同样会被修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">C</span>()</span><br><span class="line"><span class="keyword">var</span> b = a    <span class="comment">// a被复制给了b</span></span><br><span class="line">x.value = <span class="number">1</span>  <span class="comment">// a和b都被修改了</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"\(a.value), \(b.value)"</span>)<span class="comment">// "1, 1"</span></span><br></pre></td></tr></table></figure><h2 id="为什么选择值类型更安全？"><a href="#为什么选择值类型更安全？" class="headerlink" title="为什么选择值类型更安全？"></a>为什么选择值类型更安全？</h2><p>选择值类型而不是引用类型的一个主要原因是能让你的代码变得更加简单。你在任何情况下用一个值类型，都能够假设你的其他代码不会使它改变，这通常在多线程环境中很有用，如果一个线程中使用的数据被另一个线程给意外的修改了，这通常会产生非常严重的Bug，且相当难以调试。在 Objective-C 中 NSArray、NSDictionary 都是属于 NS 类，而 Swift 中 Array、Dictionary 都是属于 struct 类型，显然在后者在多线程编程中更加安全。</p><p>在 iOS 中通常创建一个类，继承自 NSObject 的时候，这就已经是引用类型，我们发现在 Objective-C 中建立 Model 的时候选择的总是继承自 NSObject 的类，而在 Swift 中通常使用 struct 来进行 Model 来建立，重要的一点原因是因为 Swift 语言中，struct、enum 都支持了定义方法，极大的扩展了可用性，再加上值类型的安全性，成了 Model 最好的选择。</p><h1 id="struct-和-class"><a href="#struct-和-class" class="headerlink" title="struct 和 class"></a>struct 和 class</h1><p>我们接下来会详细分析 struct 和 class 的异同。</p><h2 id="关于引用类型和继承关系"><a href="#关于引用类型和继承关系" class="headerlink" title="关于引用类型和继承关系"></a>关于引用类型和继承关系</h2><ul><li>struct 是值引用，class 是类型引用；</li><li>struct 没有继承，class 有继承功能；</li></ul><p>关于第一点的区别，上面已经详细讲过原理，不再赘述。第二点区别，struct 没有继承，这是因为 Swift 在本质上来说是面向协议（Protocol Oriented）的语言。</p><h2 id="关于-immutable-变量"><a href="#关于-immutable-变量" class="headerlink" title="关于 immutable 变量"></a>关于 immutable 变量</h2><p>我们都知道在 Swift 语言中，通过 let 和 var 就能够来控制不可变和可变，struct 也是遵循该规则。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="type">S</span>()</span><br><span class="line">s.value = <span class="number">1</span>         <span class="comment">// 该方法会抛出错误，Cannot assign to property: 's' is a 'let' constant</span></span><br></pre></td></tr></table></figure><p>而在 class 中，let 规则是无法延续的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">C</span>()</span><br><span class="line"><span class="built_in">c</span>.value = <span class="number">1</span>         <span class="comment">// 可以直接赋值，且不抛出错误</span></span><br></pre></td></tr></table></figure><h2 id="关于-mutating-function"><a href="#关于-mutating-function" class="headerlink" title="关于 mutating function"></a>关于 mutating function</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(<span class="number">_</span> value: Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">self</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(<span class="number">_</span> value: Int)</span></span>&#123;</span><br><span class="line">    <span class="keyword">self</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现两者的区别在于 struct 的方法中添加了 <code>mutating</code> 关键字，这是因为在 struct 中 property 是不允许在方法中修改的，如果需要在方法中修改就需要加上关键字。一般这种情况出现较少，最近在写栈数据结构的时候碰巧遇到了，比如实现栈的 pop、push 方法，就需要对栈的 property 做修改。</p><blockquote class="blockquote-center"><br><strong>版权声明</strong><br><br><img src="/cc.png" alt><br><br><a href="http://yeziahehe.com">Ivan’s Blog</a> by <a href="http://yeziahehe.com/about">Ivan Ye</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="http://yeziahehe.com/about">叶帆</a>创作并维护的<a href="http://yeziahehe.com">叶帆的博客</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。<br><br>本文首发于<a href="http://yeziahehe.com">Ivan’s Blog | 叶帆的博客</a>博客（ <a href="http://yeziahehe.com">http://yeziahehe.com</a> ），版权所有，侵权必究。<br><br>本文链接：<a href="http://yeziahehe.com/2017/09/11/class_struct_enum/">http://yeziahehe.com/2017/09/11/class_struct_enum/</a></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;Swift 中 struct、enum 都有了很大的变化，这边从基本概念开始分析，如值类型和引用类型的原理、内存管理机制等等
      
    
    </summary>
    
      <category term="技术" scheme="http://yeziahehe.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://yeziahehe.com/tags/iOS/"/>
    
      <category term="swift" scheme="http://yeziahehe.com/tags/swift/"/>
    
  </entry>
  
</feed>
